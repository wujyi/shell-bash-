# ieee754
浮点数表达法采用了科学计数法来表达实数，即用一个有效数字。一个基数（Base）、一个指数（Exponent）以及一个表示正负的符号来表达实数。比如，666.66 用十进制科学计数法可以表达为 6.6666×102（其中，6.6666 为有效数字，10 为基数，2 为指数）。浮点数利用指数达到了浮动小数点的效果，从而可以灵活地表达更大范围的实数。

当然，对实数的浮点表示仅作如上的规定是不够的，因为同一实数的浮点表示还不是唯一的。例如，上面例子中的 666.66 可以表达为 0.66666×10<sup>3</sup>、6.6666×10<sup>2</sup>或者66.666×10<sup>1</sup> 三种方式。因为这种表达的多样性，因此有必要对其加以规范化以达到统一表达的目标。规范的浮点数表达方式具有如下形式：

![图片](https://i.postimg.cc/Rh5xMNdL/2-1-PZ5112420329.jpg)

其中，`d.dd…d` 为有效数字，`β` 为基数，`e `为指数。

有效数字中数字的个数称为精度，我们可以用 p 来表示，即可称为 p 位有效数字精度。每个数字 `d `介于 `0` 和基数` β` 之间，包括 `0`。更精确地说，可以如下表示：

![图片](https://i.postimg.cc/Wb1XdsyG/2-1-PZ511253-WZ.jpg)

其中，对十进制的浮点数，即基数 β 等于 10 的浮点数而言，上面的表达式非常容易理解。如 12.34，我们可以根据上面的表达式表达为：1×10<sup>1</sup>+2×10<sup>0</sup>+3×10<sup>-1</sup>+4×10<sup>-2</sup>，其规范浮点数表达为1.234×10<sup>1</sup>。

但对二进制来说，上面的表达式同样可以简单地表达。唯一不同之处在于：二进制的 β 等于 2，而每个数字 d 只能在 0 和 1 之间取值。如二进制数 1001.101，我们可以根据上面的表达式表达为：1×2<sup>3</sup>+0×2<sup>2</sup>+0×2<sup>1</sup>+1×2<sup>0</sup>+1×2<sup>-1</sup>+0×2<sup>-2</sup>+1×2<sup>-3</sup>，其规范浮点数表达为 1.001101×2<sup>3</sup>。

现在，我们就可以这样简单地把二进制转换为十进制，如二进制数 1001.101 转换成十进制为：

![jj](https://i.postimg.cc/MG7ysL4Z/2-1-PZ5112632-H1.jpg)

由上面的等式，我们可以得出：向左移动二进制小数点一位相当于这个数除以 2，而向右移动二进制小数点一位相当于这个数乘以 2。如

$$101.11=\frac{3}{4}$$，

而 

$$10.111=\frac{7}{8}$$

除此之外，我们还可以得到这样一个基本规律：一个十进制小数要能用浮点数精确地表示，最后一位必须是 5（当然这是必要条件，并非充分条件）。规律推演如下面的示例所示：

[![2-1-PZ5112-F3244.jpg](https://i.postimg.cc/BQPPYyPW/2-1-PZ5112-F3244.jpg)](https://postimg.cc/rKcpzf9g)

我们也可以使用一段 C ++程序来验证：

```

#include <iostream>
using namespace std;
int main(void)
{
    float f1=34.6;
    float f2=34.5;
    float f3=34.0;
    cout<<"34.6-34.0="<<(f1-f3)<<'\n';
    cout<<"34.5-34.0="<<(f2-f3)<<'\n';
    return 0;
}

```

运行结果为：
```
34.6-34.0=0.599998
34.5-34.0=0.500000
```
之所以`“34.6-34.0=0.599998”`，产生这个误差的原因是` 34.6` 无法精确地表达为相应的浮点数，而只能保存为经过舍入的近似值。而这个近似值与 `34.0` 之间的运算自然无法产生精确的结果。

上面阐述了二进制数转换十进制数，如果你要将十进制数转换成二进制数，则需要把整数部分和小数部分分别转换。其中，整数部分除以` 2`，取余数；小数部分乘以 `2`，取整数位。如将 `13.125` 转换成二进制数如下：
1、首先转换整数部分（13），除以 2，取余数，所得结果为 1101。

2、其次转换小数部分（0.125），乘以 2，取整数位。转换过程如下：
`0.125×2=0.25` 取整数位0
`0.25×2=0.5`取整数位0
`0.5×2=1` 取整数位1
- 注意：可结合高程第一周作业理解

3、小数部分所得结果为 001，即 13.125=1101.001，用规范浮点数表达为 1.101001×2<sup>3</sup>。

## 浮点数表示法

IEEE 浮点数标准是从逻辑上用三元组{S，E，M}来表示一个数 V 的，即 V=（-1）S×M×2<sup>E</sup>

![jj](https://i.postimg.cc/L8M3FfP8/2-1-PZ511303-I10.jpg)

其中：
符号位` s（Sign）`决定数是正数`（s＝0）`还是负数`（s＝1）`，而对于数值` 0 `的符号位解释则作为特殊情况处理。

尾数位 `M（Significand）`是二进制小数，它的取值范围为 1 ~ 2<sup>-ε</sup>，或者为 0 ~ 1<sup>-ε</sup>。它也被称为尾数位（Mantissa）、系数位（Coefficient），甚至还被称作“小数”。

指数位 `E（Exponent）`是 2 的幂（可能是负数），它的作用是对浮点数加权

1) 格式化值

当指数段 exp 的位模式既不全为 0（即数值 0），也不全为 1（即单精度数值为 255，以单精度数为例， 8 位的指数为可以表达 0~255 的 255 个指数值)的时候，就属于这类情况。

![图片](https://i.postimg.cc/Y0RM2Q9B/2-1-PZ5113250-V9.jpg)

我们知道，指数可以为正数，也可以为负数。为了处理负指数的情况，实际的指数值按要求需要加上一个偏置（Bias）值作为保存在指数段中的值。因此，这种情况下的指数段被解释为以偏置形式表示的有符号整数。即指数的值为：E=e<sup>-Bias</sup>

其中，e 是无符号数，其位表示为 ek<sup>-1</sup>…e<sup>1</sup>e<sup>0</sup>，而 Bias 是一个等于 2<sup>k-1</sup>-1（单精度是 127，双精度是 1023）的偏置值。由此产生指数的取值范围是：单精度为 -126~+127，双精度为 -1022~+1023。

对小数段 frac，可解释为描述小数值 f，其中 0≤f<1，其二进制表示为 0.f<sub>n-1</sub>…f<sub>1</sub>f<sub>0</sub>，也就是二进制小数点在最高有效位的左边。有效数字定义为 M=1+f。有时候，这种方式也叫作隐含的以 1 开头的表示法，因为我们可以把 M 看成一个二进制表达式为 1.f<sub>n-1</sub>f<sub>n-2</sub>…f<sub>0</sub> 的数字。既然我们总是能够调整指数 E，使得有效数字 M 的范围为 1≤M<2（假设没有溢出），那么这种表示方法是一种轻松获得一个额外精度位的技巧。同时，由于第一位总是等于 1，因此我们就不需要显式地表示它。拿单精度数为例，按照上面所介绍的知识，实际上可以用 23 位长的有效数字来表达 24 位的有效数字。比如，对单精度数而言，二进制的 1001.101（即十进制的 9.625）可以表达为 1.001101×23，所以实际保存在有效数字位中的值为：
```
00110100000000000000000
```
即去掉小数点左侧的 1，并用 0 在右侧补齐。

根据上面所阐述的规则，下面以实数 -9.625 为例，来看看如何将其表达为单精度的浮点数格式。具体转换步骤如下：

1、首先，需要将 -9.625 用二进制浮点数表达出来，然后变换为相应的浮点数格式。即 -9.625 的二进制为 1001.101，用规范的浮点数表达应为 1.001101×2<sup>3</sup>。

2、其次，因为 -9.625 是负数，所以符号段为 1。而这里的指数为 3，所以指数段为 3+127=130，即二进制的 10000010。有效数字省略掉小数点左侧的 1 之后为 001101，然后在右侧用零补齐。因此所得的最终结果为：


[![2-1-PZ5113454539.jpg](https://i.postimg.cc/mrV6XVt9/2-1-PZ5113454539.jpg)](https://postimg.cc/06MfrYG5)


3、最后，我们还可以将浮点数形式表示为十六进制的数据，如下所示：

[![2-1-PZ5113513641.jpg](https://i.postimg.cc/c1K03tbh/2-1-PZ5113513641.jpg)](https://postimg.cc/nMtybrZ9)

即最终的十六进制结果为 0xC11A0000。

2) 特殊数值

IEEE 标准指定了以下特殊值：±0、反向规格化的数、±∞ 和 NaN（如下表所示）。这些特殊值都是使用 emax+1 或 emin-1 的指数进行编码的。

[![2-1-PZ51135521-X.jpg](https://i.postimg.cc/8CCqVq84/2-1-PZ51135521-X.jpg)](https://postimg.cc/RWjP7pZJ)

NaN：当指数段 exp 全为 1 时，小数段为非零时，结果值就被称为“NaN”（Not any Number）。

[![2-1-PZ5113635337.jpg](https://i.postimg.cc/sXhHjzTY/2-1-PZ5113635337.jpg)](https://postimg.cc/8JTm42Qc)


无穷：当指数段 exp 全为 1，小数段全为 0 时，得到的值表示无穷。当 s=0 时是 +∞，或者当 s=1 时是 -∞。

[![2-1-PZ5113-Z24-L.jpg](https://i.postimg.cc/xdqFZMHF/2-1-PZ5113-Z24-L.jpg)](https://postimg.cc/kV3c6VTx)



3) 非格式化值(了解即可)

当指数段 exp 全为 0 时，所表示的数就是非规格化形式。


[![2-1-PZ511393c48.jpg](https://i.postimg.cc/MpfQrGHm/2-1-PZ511393c48.jpg)](https://postimg.cc/SnqRnkWn)

在这种情况下，指数值 E=1-Bias，而有效数字的值 M=f，也就是说它是小数段的值，不包含隐含的开头的 1。

非规格化值有两个用途：

第一，它提供了一种表示数值 0 的方法。因为规格化数必须得使有效数字 M 在范围 1≤M<2 之中，即 M≥1，因此它就不能表示 0。实际上，+0.0 的浮点表示的位模式为全 0（即符号位是 0，指数段全为 0，而小数段也全为 0），这就得到 M=f=0。令人奇怪的是，当符号位为 1，而其他段全为 0 时，就会得到值 -0.0。根据 IEEE 的浮点格式来看，值 +0.0 和 -0.0 在某些方面是不同的。

第二，它表示那些非常接近于 0.0 的数。它们提供了一种属性，称为逐渐下溢出。其中，可能的数值分布均匀地接近于 0.0。



